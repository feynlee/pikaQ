# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_core.ipynb.

# %% auto 0
__all__ = ['CURRENT_ROW', 'quote_symbol', 'to_sql', 'exec', 'DelayedFunc', 'delayed_func', 'as_', 'DelayedPipeline', 'eval_type',
           'union2tuple', 'patch_to', 'patch_method', 'Field', 'ArithmeticExpression', 'Criteria', 'OverClause',
           'Preceding', 'Following', 'Table', 'custom_func', 'CustomFunction', 'add_months', 'Case', 'Query',
           'QueryBase', 'Joiner', 'Selector', 'SelectQuery', 'UnionQuery']

# %% ../nbs/01_core.ipynb 1
import inspect

from functools import partial
from fastcore.basics import *
from fastcore.meta import *
from typing import Union

try: from types import UnionType
except ImportError: UnionType = None

# %% ../nbs/01_core.ipynb 4
def quote_symbol(quote):
    """generate quote symbol to use for tables and columns"""
    if type(quote) == str:
        return quote
    else:
        if quote == True:
            return '"'
        else:
            return ''


def to_sql(l):
    if type(l) == list:
        return '(' + ', '.join([f"{item}" if type(item) in (int, float) else f"'{item}'" for item in l]) + ')'
    else:
        raise ValueError(f"type {type(l)} for l is not implemented!")


def exec(obj, **kwargs):
    """Call the exec method of `obj` if it exists, otherwise return the string representation of `obj`"""
    if hasattr(obj, 'exec'):
        return obj.exec(**kwargs)
    else:
        return str(obj)

# %% ../nbs/01_core.ipynb 6
class DelayedFunc:
    """Delay the execution of stored function until exec is run."""
    def __init__(self, func, args, kwargs, order=None) -> None: 
        store_attr()

    def exec(self, **kwargs):
        """keyword arguments can be overwritten with any provided new kwargs."""
        self.kwargs.update(kwargs)
        # recursively resolve all delayed functions
        args = (exec(arg, **self.kwargs) for arg in self.args) 
        return self.func(*args, **self.kwargs)


def delayed_func(func):
    """return Delayed function"""
    def wrapper(*args, **kwargs):
        return DelayedFunc(func, args, kwargs)
    return wrapper

# %% ../nbs/01_core.ipynb 10
def as_(self, alias):
    if self.res:
        self.alias = alias
        return self.res + f" AS {alias}"
    else:
        raise ValueError(f"self.res is {self.res}, can not append AS statement!")


class DelayedPipeline:
    """Execute delayed methods in self.dp in order when .exec is called."""
    dic = {
        'as_': {
            'order': None,
            'dialect': {
                'sql': as_
            }
        }
    }

    def __init__(self) -> None: 
        self.dp = []  # record all delayed functions
        self.ress = []  # save all intermediate results
        self.alias_allowed=True

    def __getattr__(self, attr):
        def _func(*args, dialect='sql', **kwargs):
            try: 
                return self.dic[attr]['dialect'][dialect](self, *args, **kwargs)
            except:
                raise KeyValueError(f"dialect {dialect} is not implemented for {attr}!")

        def wrapper(*args, **kwargs):
            dlf = DelayedFunc(_func, args, kwargs)
            dlf.order = self.dic[attr]['order']
            self.dp.append(dlf)
            return self
        return wrapper

    @property
    def res(self):
        if self.ress:
            return self.ress[-1]

    def _order_dp(self):
        dp_none = [d for d in self.dp if d.order is None]
        dp_order = [d for d in self.dp if d.order is not None]
        dp_order.sort(key=lambda x: x.order)
        self.dp = dp_order + dp_none

    def exec(self, **kwargs):
        self._order_dp()
        if self.dp:
            for d in self.dp:
                # save all intermediate steps in resolving the sql query
                self.ress.append(d.exec(**kwargs))
            self.dp = [] # clear the pipeline
        return self.res


def eval_type(t):
    "`eval` a type or collection of types, if needed, for annotations in py3.10+"
    if isinstance(t,str):
        if '|' in t: return Union[eval_type(tuple(t.split('|')))]
        return eval(t)
    if isinstance(t,(tuple,list)): return type(t)([eval_type(c) for c in t])
    return t


def union2tuple(t):
    if (getattr(t, '__origin__', None) is Union
        or (UnionType and isinstance(t, UnionType))): return t.__args__
    return t


def patch_to(func, dialect='sql'):
    ann = getattr(func, '__annotations__', None)
    nm = func.__name__
    cls = union2tuple(eval_type(next(iter(ann.values()))))
    if not isinstance(cls, (tuple,list)): cls=(cls,)
    for c_ in cls: 
        dic = getattr(c_, 'dic', None)
        if dic is not None:
            if nm not in dic:
                dic[nm] = {'order': None, 'dialect': {}}
            subdic = dic[nm]['dialect']
            subdic.update({dialect: func})
            dic[nm]['dialect'] = subdic
            c_.dic = dic
        else:
            raise ValueError(f"{c_} does not have class attribute `dic`, and can not be patched by path_method!")
    return func

        
def patch_method(func=None, dialect='sql'):
    if func is None: return partial(patch_method, dialect=dialect)
    return patch_to(func, dialect)

# %% ../nbs/01_core.ipynb 16
def _over(self, partition_by):
    return OverClause(self).over(partition_by)


class Field(DelayedPipeline):
    def __init__(self, name=None, window_func=True) -> None: 
        super().__init__()
        self.alias_allowed=True
        if window_func: 
            Field.over=_over
        if name:
            self.alias = name
            self.ress.append(name)
        self.sql = self.res
    
    def __add__(self, other):
        return ArithmeticExpression(self, '+', other)

    def __radd__(self, other):
        return ArithmeticExpression(other, '+', self)

    def __sub__(self, other):
        return ArithmeticExpression(self, '-', other)

    def __rsub__(self, other):
        return ArithmeticExpression(other, '-', self)

    def __mul__(self, other):
        return ArithmeticExpression(self, '*', other)
        
    def __rmul__(self, other):
        return ArithmeticExpression(other, '*', self)

    def __truediv__(self, other):
        return ArithmeticExpression(self, '/', other)

    def __rtruediv__(self, other):
        return ArithmeticExpression(other, '/', self)

    def __gt__(self, other):
        return Criteria(self, '>', other)

    def __ge__(self, other):
        return Criteria(self, '>=', other)
        
    def __eq__(self, other):
        return Criteria(self, '==', other)

    def __ne__(self, other):
        return Criteria(self, '!=', other)

    def __le__(self, other):
        return Criteria(self, '<=', other)

    def __lt__(self, other):
        return Criteria(self, '<', other)


class ArithmeticExpression(Field):
# class ArithmeticExpression:
    add_order = ["+", "-"]

    def __init__(self, this, op, other) -> None:
        super().__init__()
        self.this, self.op, self.other = this, op, other

    def __add__(self, other):
        return ArithmeticExpression(self, '+', other)

    def __radd__(self, other):
        return ArithmeticExpression(other, '+', self)

    def __sub__(self, other):
        return ArithmeticExpression(self, '-', other)

    def __rsub__(self, other):
        return ArithmeticExpression(other, '-', self)

    def __mul__(self, other):
        return ArithmeticExpression(self, '*', other)
        
    def __rmul__(self, other):
        return ArithmeticExpression(other, '*', self)

    def __truediv__(self, other):
        return ArithmeticExpression(self, '/', other)

    def __rtruediv__(self, other):
        return ArithmeticExpression(other, '/', self)
    
    def __gt__(self, other):
        return Criteria(self, '>', other)

    def __ge__(self, other):
        return Criteria(self, '>=', other)
        
    def __eq__(self, other):
        return Criteria(self, '==', other)

    def __ne__(self, other):
        return Criteria(self, '!=', other)

    def __le__(self, other):
        return Criteria(self, '<=', other)

    def __lt__(self, other):
        return Criteria(self, '<', other)

    def left_needs_parens(self, left_op, curr_op) -> bool:
        """
        Returns true if the expression on the left of the current operator needs to be enclosed in parentheses.
        :param current_op:
            The current operator.
        :param left_op:
            The highest level operator of the left expression.
        """
        if left_op is None or curr_op in self.add_order:
            # If the left expression is a single item.
            # or if the current operator is '+' or '-'.
            return False
        
        # The current operator is '*' or '/'. 
        # If the left operator is '+' or '-', we need to add parentheses:
        # e.g. (A + B) / ..., (A - B) / ...
        # Otherwise, no parentheses are necessary:
        # e.g. A * B / ..., A / B / ...
        return left_op in self.add_order

    def right_needs_parens(self, curr_op, right_op) -> bool:
        """
        Returns true if the expression on the right of the current operator needs to be enclosed in parentheses.
        :param current_op:
            The current operator.
        :param right_op:
            The highest level operator of the right expression.
        """
        if right_op is None:
            # If the right expression is a single item.
            return False
        # If the right operator is '+' or '-', we always add parentheses:
        # e.g. ... - (A + B), ... - (A - B), ... + (A + B)
        # Otherwise, no parentheses are necessary:
        # e.g. ... - A / B, ... - A * B
        return right_op in self.add_order

    def exec(self, **kwargs):
        if self.this.__class__ is ArithmeticExpression:
            this = self.this.exec(**kwargs)
            this = f"({this})" if self.left_needs_parens(self.this.op, self.op) else this
        elif getattr(self.this, 'exec', None):
            this = self.this.exec(**kwargs)
        else:
            this = str(self.this)

        if self.other.__class__ is ArithmeticExpression:
            other = self.other.exec(**kwargs)
            other = f"({other})" if self.right_needs_parens(self.op, self.other.op) else other
        elif getattr(self.other, 'exec', None):
            other = self.other.exec(**kwargs)
        else:
            other = str(self.other)
        return f"{this} {self.op} {other}"


class Criteria(Field):
    compose_ops = ('and', 'or')

    def __init__(self, this, op, other) -> None:
        super().__init__()
        self.this, self.op, self.other = this, op, other
        self.add_parentheses = False

    def compose_criteria(self, op, other):
        if other.__class__ is Criteria:
            if self.op in self.compose_ops and op in self.compose_ops and self.op != op:
                self.add_parentheses = True
            if other.op in self.compose_ops and op in self.compose_ops and other.op != op:
                other.add_parentheses = True
        return Criteria(self, op, other)

    @staticmethod
    def resolve(obj, **kwargs):
        if obj.__class__ is Criteria:
            obj_c = obj.exec(**kwargs)
            obj_c = f"({obj_c})" if obj.add_parentheses == True else obj_c
        elif getattr(obj, 'exec', None):
            obj_c = obj.exec(**kwargs)
        else:
            obj_c = str(obj)
        return obj_c
    
    def exec(self, **kwargs):
        this = self.resolve(self.this, **kwargs)
        other = self.resolve(self.other, **kwargs)
        return f"{this} {self.op} {other}"

    def __and__(self, __o):
        return self.compose_criteria('and', __o)

    def __or__(self, __o):
        return self.compose_criteria('or', __o)


class OverClause:
    def __init__(self, expression) -> None:
        if not (isinstance(expression, Field) or type(expression) is str):
            raise ValueError(f"Expression has to be of the Field type (including ArithmeticExpression)!!")
        self.expr = expression
        self.alias = None
        self.rows_flag = False
        self.range_flag = False
        self.d = {}

    def over(self, q):
        self.d['PARTITION BY'] = q
        return self

    def orderby(self, q):
        self.d['ORDER BY'] = q
        return self

    def _check_rows_or_range(self):
        if self.rows_flag==True: 
            raise ValueError(f"ROWS already set!")
        if self.range_flag==True:
            raise ValueError(f"RANGE already set!")

    def rows(self, start, end):
        self._check_rows_or_range()
        self.rows = True
        self.d['ROWS'] = (start, end)
        return self

    def range(self, start, end):
        self._check_rows_or_range()
        self.range = True
        self.d['RANGE'] = (start, end)
        return self

    def as_(self, alias):
        self.alias = alias
        return self

    def _resolve_over_statement(self, **kwargs):
        sql = []
        for k in ['PARTITION BY', 'ORDER BY', 'ROWS', 'RANGE']:
            if k in self.d:
                if k in ['PARTITION BY', 'ORDER BY']:
                    rslvd = f"{k} {exec(self.d[k], **kwargs)}"
                else:
                    start, end = self.d[k]
                    rslvd = f"{k} BETWEEN {exec(start, **kwargs)} AND {exec(end, **kwargs)}"
                sql.append(rslvd)
        return f"{exec(self.expr, **kwargs)} OVER ({' '.join(sql)})"

    def exec(self, **kwargs):
        sql = self._resolve_over_statement(**kwargs)
        if self.alias:
            return f"{sql} AS {self.alias}"
        else:
            return sql


class Preceding:
    def __init__(self, N=None) -> None:
        self.N = N

    def exec(self, **kwargs):
        if self.N:
            return f"{self.N} PRECEDING"
        else:
            return "UNBOUNDED PRECEDING"


class Following:
    def __init__(self, N=None) -> None:
        self.N = N

    def exec(self, **kwargs):
        if self.N:
            return f"{self.N} FOLLOWING"
        else:
            return "UNBOUNDED FOLLOWING"


CURRENT_ROW = "CURRENT_ROW"



# %% ../nbs/01_core.ipynb 21
class Table:
    def __init__(self, name) -> None:
        store_attr()
        self.alias = name
        # self.name = self.alias = name

    def as_(self, alias):
        self.alias = alias
        return self

    def __getattr__(self, __name: str):
        if __name.startswith('__'):
            raise AttributeError
            # return super().__getattr__(__name)
        else:
            return Field(f"{self.alias}.{__name}")
    
    def exec(self, **kwargs):
        if self.alias != self.name:
            return f"{self.name} as {self.alias}"
        else:
            return self.name

# %% ../nbs/01_core.ipynb 24
def _kwargs_func(func, *args, **kwargs):
    "Allow arbitrary kwargs. Only pass those kwargs that are specified in func to func."
    sig = inspect.signature(func)
    param = sig.parameters
    func_kwargs = {k:v for k, v in param.items() if v.default!=inspect._empty}
    kwargs = {k:v for k, v in kwargs.items() if k in func_kwargs}
    return func(*args, **kwargs)


def custom_func(func=None, window_func=False, dialect=None):
    """return Field"""
    if func is None: 
        return partial(custom_func, window_func=window_func, dialect=dialect)
    else:
        if dialect is None:
            def wrapper(*args, **kwargs):
                dlf = DelayedFunc(func, args, kwargs)
                f = Field(window_func=window_func)
                f.dp.append(dlf)
                return f
        else:
            # get previously defined func
            func_name = func.__name__
            ori_func = globals().get(func_name)
            def wrapper(*args, **kwargs):
                def new_func(*args, **kwargs):
                    if kwargs['dialect'] != dialect and ori_func:
                        f = ori_func().dp[0].func
                    else:
                        f = func
                    return _kwargs_func(f, *args, **kwargs)

                # make new delayed function
                dlf = DelayedFunc(new_func, args, kwargs)

                # append the delayed function to Field.dp
                f = Field(window_func=window_func)
                f.dp.append(dlf)
                return f
        return wrapper


class CustomFunction(Field):
    def __init__(self, func_name, args) -> None:
        super().__init__()
        self.func_name = func_name
        self.args = args
    
    def __call__(self, *args):
        if len(args) != len(self.args):
            raise ValueError(f"The number of args provided {len(args)} is not the same as the number of args expected by this function ({len(self.args)})!")
        def func(*args):
            return f"{self.func_name}({', '.join(args)})"

        dlf = DelayedFunc(func, args, {})
        self.dp.append(dlf)
        return self


@custom_func
def add_months(column, num, dialect='sql'):
    if dialect=='sql':
        return f'DATE_ADD(month, {num}, {column})'
    elif dialect=='snowflake':
        return f'MONTH_ADD({column}, {num})'

# %% ../nbs/01_core.ipynb 31
class Case:
    def __init__(self) -> None:
        self.dp = []
        self.alias = None

    def check_prev(self, statement):
        if self.dp:
            prev = self.dp[0][0]
            if prev == statement:
                return True
        return False

    def when(self, q, then):
        if self.check_prev('ELSE'):
            raise ValueError(f"'WHEN' can not follow 'ELSE'!")
        self.dp.append(('WHEN', q, then))
        return self

    def else_(self, q):
        self.dp.append(('ELSE', q))
        return self

    def _as(self, alias):
        self.alias = alias
        return self

    def exec(self, **kwargs):
        sql = ["CASE"]
        for item in self.dp:
            if item[0] == 'WHEN':
                q_resolved = f"WHEN {exec(item[1], **kwargs)} THEN {exec(item[2], **kwargs)}"
            else:
                q_resolved = f"ELSE {exec(item[1], **kwargs)}"
            sql.append(q_resolved)
        if self.alias:
            sql.append(f"END AS {self.alias}")
        else:
            sql.append("END")
        return '\n'.join(sql)


# %% ../nbs/01_core.ipynb 34
class Query:
    @classmethod
    def from_(cls, query):
        q = SelectQuery()
        q.dic['from'] = query
        return q

    @classmethod
    def with_(cls, query, alias):
        q = SelectQuery()
        q.dic['with'] = [(query, alias)]
        return q


class QueryBase:
    pass


class Joiner(QueryBase):
    def __init__(self, select_query, query, how=None) -> None:
        store_attr()

    def on(self, condition):
        l = self.select_query.dic.get('join', [])
        l.append((self.query, self.how, condition))
        self.select_query.dic['join'] = l
        return self.select_query


class Selector(QueryBase):
    def __init__(self, select_query, *args) -> None:
        self.select_query = select_query
        self.select_query.dic['select'] = list(args)

    def __getattr__(self, __name: str):
        return getattr(self.select_query, __name)

    def distinct(self):
        self.select_query.dic['distinct'] = True
        return self.select_query


class SelectQuery(QueryBase):
    keys_simple = ['from', 'group by', 'order by', 'where', 'having', 'limit']
    keys_parse = ['with', 'from', 'join', 'on', 'where', 'group by', 'having', 'order by', 'select', 'limit']
    keys_sql = ['with', 'select', 'from', 'join', 'on', 'where', 'group by', 'having', 'order by', 'limit']
    key_translate = {
        'groupby': 'group by',
        'orderby': 'order by'
    }

    def __init__(self) -> None:
        super().__init__()
        self.dic = {}

    def join(self, query, how=None):
        q = Joiner(self, query, how)
        return q

    def select(self, *args):
        return Selector(self, *args)

    @staticmethod
    def _resolve(q, **kwargs):
        if getattr(q, 'exec', None):
            return q.exec(**kwargs)
        else:
            return str(q)

    def __getattr__(self, __name):
        __name = __name.strip('_')

        if __name.startswith('exec'):
            # for exec_{key} methods
            key = __name.split('_')[-1]

            def inner(**kwargs):
                if key in self.keys_simple:
                    q = self.dic[key]
                    if isinstance(q, QueryBase):
                        return f"{self.key_translate.get(key, key)} ({self._resolve(q, **kwargs)})"
                    else:
                        return f"{self.key_translate.get(key, key)} {self._resolve(q, **kwargs)}"
                elif key == 'with':
                    s = self.dic[key]
                    qq = [f"{a} as ({self._resolve(q, **kwargs)})" for q, a in s]
                    return f"{key} " + ",\n".join(qq)
                elif key == 'join':
                    l = self.dic[key]
                    parsed = []
                    for q, how, cond in l:
                        if how:
                            how = how + ' '
                        else:
                            how = ''
                        if isinstance(q, QueryBase):
                            sub_q = f"({self._resolve(q, **kwargs)})"
                        else:
                            sub_q = self._resolve(q, **kwargs)
                        parsed.append(f"{how}join {sub_q} on {self._resolve(cond, **kwargs)}")
                    return '\n'.join(parsed)
                elif key == 'select':
                    args = self.dic[key]
                    columns = [self._resolve(arg, **kwargs) for arg in args]
                    if self.dic.get('distinct'):
                        return f"{key} distinct " + ', '.join(columns)
                    else:
                        return f"{key} " + ', '.join(columns)
                else:
                    raise AttributeError(f"{__name} is not a valid attribute!")
        elif __name in self.keys_simple:
            def inner(query):
                self.dic[__name] = query
                return self
        elif __name in ['with']:
            def inner(query, alias):
                l = self.dic.get('with', [])
                l.append((query, alias))
                self.dic['with'] = l
                return self
        else:
            raise AttributeError(f"{__name} is not a valid attribute!")

        return inner


    def exec(self, **kwargs):
        dic_sql = {}

        for key in self.keys_parse:
            if key in self.dic:
                dic_sql[key] = getattr(self, f'exec_{key}')(**kwargs)

        sql = '\n'.join([dic_sql[key] for key in self.keys_sql if key in dic_sql])
        return sql
    
    def union(self, query):
        if not isinstance(query, QueryBase):
            raise TypeError(f"{query} is not an instance of QueryBase!")
        return UnionQuery(self, query, union_type='UNION')

    def __add__(self, query):
        return self.union(query)

    def union_all(self, query):
        if not isinstance(query, QueryBase):
            raise TypeError(f"{query} is not an instance of QueryBase!")
        return UnionQuery(self, query, union_type='UNION ALL')

    def __mul__(self, query):
        return self.union_all(query)


class UnionQuery:
    def __init__(self, q1, q2, union_type='UNION') -> None:
        store_attr()

    def exec(self, **kwargs):
        return f"{exec(self.q1, **kwargs)} {self.union_type} {exec(self.q2, **kwargs)}"
    
