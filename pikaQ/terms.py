# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_terms.ipynb.

# %% auto 0
__all__ = ['Field', 'ArithmeticExpression', 'Criteria', 'Table', 'Case']

# %% ../nbs/03_terms.ipynb 2
from fastcore.basics import *
from fastcore.meta import *
from fastcore.xtras import *
from nbdev.cli import *

# %% ../nbs/03_terms.ipynb 5
class Field(DelayedSQL):
    def __init__(self, name) -> None: 
        super().__init__()
        self.alias_allowed=True
        self.alias = name
        self.sql = name

    def as_(self, alias):
        if self.alias_allowed:
            self.alias = alias
        else:
            raise ValueError(f'alias is not allowed!')
        return self

    @delayed_method
    def comp(self, symbol, __o):
        self.alias_allowed = False
        if type(__o) == str:
            __o = f"'{__o}'"
        l = f"{self.alias} {symbol} {__o}"
        return Criteria(l, op=symbol)

    def __eq__(self, __o: object):
        return self.comp('==', __o)

    def __ne__(self, __o: object):
        return self.comp('!=', __o)

    def __gt__(self, __o: object):
        return self.comp('>', __o)

    def __ge__(self, __o: object):
        return self.comp('>=', __o)

    def __lt__(self, __o: object):
        return self.comp('<', __o)
        
    def __le__(self, __o: object):
        return self.comp('<=', __o)

    def isin(self, l: list):
        l = [self.alias, 'IN', to_sql(l)]
        return Criteria(l)

    def notin(self, l: list):
        l = [self.alias, 'NOT', 'IN', to_sql(l)]
        return Criteria(l)

    def isnull(self):
        l = [self.alias, 'IS', 'NULL']
        return Criteria(l)

    def notnull(self):
        l = [self.alias, 'IS', 'NOT', 'NULL']
        return Criteria(l)

    def like(self, pat):
        l = [self.alias, 'LIKE', pat]
        return Criteria(l)

    def ilike(self, pat):
        l = [self.alias, 'ILIKE', pat]
        return Criteria(l)


class ArithmeticExpression(DelayedList):
    add_order = ["+", "-"]

    def __init__(self, l, op=None, **kwargs) -> None:
        super().__init__(l, **kwargs)
        self.op = op

    def left_needs_parens(self, curr_op, left_op) -> bool:
        """
        Returns true if the expression on the left of the current operator needs to be enclosed in parentheses.
        :param current_op:
            The current operator.
        :param left_op:
            The highest level operator of the left expression.
        """
        if left_op is None or curr_op in self.add_order:
            # If the left expression is a single item.
            # or if the current operator is '+' or '-'.
            return False
        
        # The current operator is '*' or '/'. 
        # If the left operator is '+' or '-', we need to add parentheses:
        # e.g. (A + B) / ..., (A - B) / ...
        # Otherwise, no parentheses are necessary:
        # e.g. A * B / ..., A / B / ...
        return left_op in self.add_order

    def right_needs_parens(self, curr_op, right_op) -> bool:
        """
        Returns true if the expression on the right of the current operator needs to be enclosed in parentheses.
        :param current_op:
            The current operator.
        :param right_op:
            The highest level operator of the right expression.
        """
        if right_op is None:
            # If the right expression is a single item.
            return False
        # If the right operator is '+' or '-', we always add parentheses:
        # e.g. ... - (A + B), ... - (A - B), ... + (A + B)
        # Otherwise, no parentheses are necessary:
        # e.g. ... - A / B, ... - A * B
        return right_op in self.add_order

    def get_sql(self, with_alias: bool = False, **kwargs) -> str:
        left_op, right_op = [getattr(side, "operator", None) for side in [self.left, self.right]]

        arithmetic_sql = "{left}{operator}{right}".format(
            operator=self.operator.value,
            left=("({})" if self.left_needs_parens(self.operator, left_op) else "{}").format(
                self.left.get_sql(**kwargs)
            ),
            right=("({})" if self.right_needs_parens(self.operator, right_op) else "{}").format(
                self.right.get_sql(**kwargs)
            ),
        )

        if with_alias:
            return format_alias_sql(arithmetic_sql, self.alias, **kwargs)

        return arithmetic_sql


class Criteria(DelayedList):
    def __init__(self, l, op=None, **kwargs) -> None:
        super().__init__(l, **kwargs)
        self.op = op

    def add_left_parentheses(self, l):
        l_first = l[0]
        if type(l_first) == str:
            l[0] = '('+l_first
            return l
        else:
            l[0] = self.add_left_parentheses(l_first)
            return l

    def add_right_parentheses(self, l):
        l_last = l[-1]
        if type(l_last) == str:
            l[-1] = l_last + ')'
            return l
        else:
            l[-1] = self.add_right_parentheses(l_last)
            return l

    def add_parentheses(self, l):
        l = self.add_left_parentheses(l)
        l = self.add_right_parentheses(l)
        return l

    def compose_criteria(self, op, __o):
        left = self.l 
        right = __o.l
        if self.op is not None and self.op != op:
            left = self.add_parentheses(left)
            self.l = left
        if __o.op is not None and __o.op != op:
            right = self.add_parentheses(right)
            __o.l = right
        l = [self, op, __o]
        return Criteria(l, op=op)

    def __and__(self, __o):
        return self.compose_criteria('and', __o)

    def __or__(self, __o):
        return self.compose_criteria('or', __o)


# %% ../nbs/03_terms.ipynb 8
class Table:
    def __init__(self, name) -> None: 
        self.alias = name

    @delayed_term
    def field_name(self, field_name, in_select=False, joined_query=False, quote=True):
        table_name = self.alias
        q = quote_symbol(quote)
        if in_select and not joined_query:
            return f"{q}{field_name}{q}"
        else:
            return f"{q}{table_name}{q}.{q}{field_name}{q}"

    def as_(self, alias):
        self.alias = alias
        return self

    def __getattr__(self, __name: str):
        return  Field(self.field_name(__name))



# %% ../nbs/03_terms.ipynb 11
class Case(DelayedList):
    def __init__(self, sep=' ', **kwargs) -> None:
        l = ['CASE']
        super().__init__(l, sep=sep, **kwargs)

    def when(self, c: Criteria, value): 
        self.append(DelayedList(['WHEN', c, 'THEN', value]))
        return self
    
    def else_(self, value):
        self.append(DelayedList(['ELSE', value, 'END']))
        return self

    def as_(self, alias):
        self.alias = alias
        self.append(['AS', alias])
        return self


