# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_queries.ipynb.

# %% auto 0
__all__ = ['Table', 'Query', 'QueryBase', 'Joiner', 'Selector', 'SelectQuery', 'UnionQuery']

# %% ../nbs/03_queries.ipynb 2
from .terms import Field

# %% ../nbs/03_queries.ipynb 4
class Table:
    def __init__(self, name) -> None:
        self.name = self.alias = name
        self.get_sql = self.exec

    def as_(self, alias):
        self.alias = alias
        return self

    def __getattr__(self, __name: str):
        if __name.startswith('__'):
            raise AttributeError
        else:
            # if an alias is assigned, always use it as the table name when accessing a field
            return Field(f"{self.alias}.{__name}")
    
    def exec(self, **kwargs):
        if self.alias != self.name:
            return f"{self.name} as {self.alias}"
        else:
            return self.name

# %% ../nbs/03_queries.ipynb 7
class Query:
    @classmethod
    def from_(cls, query):
        q = SelectQuery()
        q.dic['from'] = query
        return q

    @classmethod
    def with_(cls, query, alias):
        q = SelectQuery()
        q.dic['with'] = [(query, alias)]
        return q


class QueryBase:
    pass


class Joiner(QueryBase):
    def __init__(self, select_query, query, how=None) -> None:
        self.select_query = select_query
        self.query = query
        self.how = how

    def on(self, condition):
        l = self.select_query.dic.get('join', [])
        l.append((self.query, self.how, condition))
        self.select_query.dic['join'] = l
        return self.select_query


class Selector(QueryBase):
    def __init__(self, select_query, *args) -> None:
        self.select_query = select_query
        self.select_query.dic['select'] = list(args)

    def __getattr__(self, __name: str):
        return getattr(self.select_query, __name)

    def distinct(self):
        self.select_query.dic['distinct'] = True
        return self.select_query


class SelectQuery(QueryBase):
    keys_simple = ['from', 'group by', 'order by', 'where', 'having', 'limit']
    keys_parse = ['with', 'from', 'join', 'on', 'where', 'group by', 'having', 'order by', 'select', 'limit']
    keys_sql = ['with', 'select', 'from', 'join', 'on', 'where', 'group by', 'having', 'order by', 'limit']
    key_translate = {
        'groupby': 'group by',
        'orderby': 'order by'
    }

    def __init__(self) -> None:
        super().__init__()
        self.dic = {}

    def join(self, query, how=None):
        q = Joiner(self, query, how)
        return q

    def select(self, *args):
        return Selector(self, *args)

    @staticmethod
    def _resolve(q, **kwargs):
        if getattr(q, 'exec', None):
            return q.exec(**kwargs)
        else:
            return str(q)

    def __getattr__(self, __name):
        __name = __name.strip('_')

        if __name.startswith('exec'):
            # for exec_{key} methods
            key = __name.split('_')[-1]

            def inner(**kwargs):
                if key in self.keys_simple:
                    q = self.dic[key]
                    if isinstance(q, QueryBase):
                        return f"{self.key_translate.get(key, key)} ({self._resolve(q, **kwargs)})"
                    else:
                        return f"{self.key_translate.get(key, key)} {self._resolve(q, **kwargs)}"
                elif key == 'with':
                    s = self.dic[key]
                    qq = [f"{a} as ({self._resolve(q, **kwargs)})" for q, a in s]
                    return f"{key} " + ",\n".join(qq)
                elif key == 'join':
                    l = self.dic[key]
                    parsed = []
                    for q, how, cond in l:
                        if how:
                            how = how + ' '
                        else:
                            how = ''
                        if isinstance(q, QueryBase):
                            sub_q = f"({self._resolve(q, **kwargs)})"
                        else:
                            sub_q = self._resolve(q, **kwargs)
                        parsed.append(f"{how}join {sub_q} on {self._resolve(cond, **kwargs)}")
                    return '\n'.join(parsed)
                elif key == 'select':
                    args = self.dic[key]
                    columns = [self._resolve(arg, **kwargs) for arg in args]
                    if self.dic.get('distinct'):
                        return f"{key} distinct " + ', '.join(columns)
                    else:
                        return f"{key} " + ', '.join(columns)
                else:
                    raise AttributeError(f"{__name} is not a valid attribute!")
        elif __name in self.keys_simple:
            def inner(query):
                self.dic[__name] = query
                return self
        elif __name in ['with']:
            def inner(query, alias):
                l = self.dic.get('with', [])
                l.append((query, alias))
                self.dic['with'] = l
                return self
        else:
            raise AttributeError(f"{__name} is not a valid attribute!")

        return inner


    def exec(self, **kwargs):
        dic_sql = {}

        for key in self.keys_parse:
            if key in self.dic:
                dic_sql[key] = getattr(self, f'exec_{key}')(**kwargs)

        sql = '\n'.join([dic_sql[key] for key in self.keys_sql if key in dic_sql])
        return sql
    
    def union(self, query):
        if not isinstance(query, QueryBase):
            raise TypeError(f"{query} is not an instance of QueryBase!")
        return UnionQuery(self, query, union_type='UNION')

    def __add__(self, query):
        return self.union(query)

    def union_all(self, query):
        if not isinstance(query, QueryBase):
            raise TypeError(f"{query} is not an instance of QueryBase!")
        return UnionQuery(self, query, union_type='UNION ALL')

    def __mul__(self, query):
        return self.union_all(query)


class UnionQuery:
    def __init__(self, q1, q2, union_type='UNION') -> None:
        self.q1 = q1
        self.q2 = q2
        self.union_type = union_type

    def exec(self, **kwargs):
        return f"{exec(self.q1, **kwargs)} {self.union_type} {exec(self.q2, **kwargs)}"
    
