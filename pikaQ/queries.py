# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_queries.ipynb.

# %% auto 0
__all__ = ['Table', 'Query', 'QueryBase', 'Joiner', 'Selector', 'SelectQuery', 'UnionQuery', 'Exists']

# %% ../nbs/04_queries.ipynb 2
from .utils import execute
from .terms import Field

# %% ../nbs/04_queries.ipynb 4
class Table:
    def __init__(self, name) -> None:
        self.name = self.alias = name
        self.get_sql = self.execute

    def as_(self, alias):
        self.alias = alias
        return self

    def __getattr__(self, __name: str):
        if __name.startswith('__'):
            raise AttributeError
        else:
            # if an alias is assigned, always use it as the table name when accessing a field
            return Field(f"{self.alias}.{__name}")

    def quoted_name(self, quote_char):
        name_list = self.name.split('.')
        name = '.'.join([f"{quote_char}{n}{quote_char}" for n in name_list])
        return name
    
    def execute(self, **kwargs):
        q = kwargs.get('quote_char', '') or ''
        quoted_name = self.quoted_name(q)
        if self.alias != self.name:
            return f"{quoted_name} as {q}{self.alias}{q}"
        else:
            return quoted_name

# %% ../nbs/04_queries.ipynb 7
class Query:
    @classmethod
    def from_(cls, query):
        q = SelectQuery()
        q.dic['from'] = query
        return q

    @classmethod
    def with_(cls, query, alias):
        q = SelectQuery()
        q.dic['with'] = [(query, alias)]
        return q


class QueryBase:
    pass


class Joiner(QueryBase):
    """Join clause has to be followed by an on clause"""
    def __init__(self, select_query, query, how=None) -> None:
        self.select_query = select_query
        self.query = query
        self.how = how

    def on(self, condition):
        l = self.select_query.dic.get('join', [])
        l.append((self.query, self.how, condition))
        self.select_query.dic['join'] = l
        return self.select_query


class Selector(QueryBase):
    """Select clause could be followed by a distinct clause"""
    def __init__(self, select_query, *args) -> None:
        self.select_query = select_query
        self.select_query.dic['select'] = list(args)

    def __getattr__(self, __name: str):
        # selector inherits all methods from the SelectQuery object
        # so that the distinct method is optional
        return getattr(self.select_query, __name)

    def distinct(self):
        self.select_query.dic['distinct'] = True
        return self.select_query


class SelectQuery(QueryBase):
    keys_simple = ['from', 'groupby', 'orderby', 'where', 'having', 'limit']
    # the order to parse different parts of the sql query
    keys_parse = ['with', 'from', 'join', 'where', 'groupby', 'having', 'orderby', 'select', 'limit']
    # the order to put together the final sql query
    keys_sql = ['with', 'select', 'from', 'join', 'where', 'groupby', 'having', 'orderby', 'limit']
    key_translation = {
        'groupby': 'group by',
        'orderby': 'order by'
    }

    def __init__(self) -> None:
        self.dic = {}
        self.get_sql = self.execute

    def join(self, query, how=None):
        return Joiner(self, query, how)

    def select(self, *args):
        return Selector(self, *args)

    def parse(self, key, **kwargs):
        if key in self.keys_simple:
            q = self.dic[key]
            if isinstance(q, QueryBase):
                return f"{self.key_translation.get(key, key)} ({execute(q, **kwargs)})"
            else:
                return f"{self.key_translation.get(key, key)} {execute(q, **kwargs)}"
        elif key == 'with':
            s = self.dic[key]
            qq = [f"{a} as ({execute(q, **kwargs)})" for q, a in s]
            return f"{key} " + ",\n".join(qq)
        elif key == 'join':
            l = self.dic[key]
            parsed = []
            for q, how, cond in l:
                if how:
                    how = how + ' '
                else:
                    how = ''
                if isinstance(q, QueryBase):
                    sub_q = f"({execute(q, **kwargs)})"
                else:
                    sub_q = execute(q, **kwargs)
                parsed.append(f"{how}join {sub_q} on {execute(cond, **kwargs)}")
            return '\n'.join(parsed)
        elif key == 'select':
            args = self.dic[key]
            columns = [execute(arg, **kwargs) for arg in args]
            if self.dic.get('distinct'):
                return f"{key} distinct " + ', '.join(columns)
            else:
                return f"{key} " + ', '.join(columns)
        else:
            raise AttributeError(f"{key} is not a valid attribute!")

    def __getattr__(self, __name):
        # Construct the corresponding method functions
        __name = __name.split('_')[0].lower()

        if __name in self.keys_simple:
            def inner(query):
                self.dic[__name] = query
                return self
        elif __name == 'with':
            def inner(query, alias):
                l = self.dic.get('with', [])
                l.append((query, alias))
                self.dic['with'] = l
                return self
        else:
            raise AttributeError(f"{__name} is not a valid attribute!")

        return inner

    def execute(self, **kwargs):
        dic_sql = {}

        for key in self.keys_parse:
            if key in self.dic:
                dic_sql[key] = self.parse(key, **kwargs)

        sql = '\n'.join([dic_sql[key] for key in self.keys_sql if key in dic_sql])
        return sql
    
    def union(self, query):
        if not isinstance(query, QueryBase):
            raise TypeError(f"{query} is not an instance of QueryBase!")
        return UnionQuery(self, query, union_type='UNION')

    def __add__(self, query):
        return self.union(query)

    def union_all(self, query):
        if not isinstance(query, QueryBase):
            raise TypeError(f"{query} is not an instance of QueryBase!")
        return UnionQuery(self, query, union_type='UNION ALL')

    def __mul__(self, query):
        return self.union_all(query)


class UnionQuery:
    def __init__(self, q1, q2, union_type='UNION') -> None:
        self.q1 = q1
        self.q2 = q2
        self.union_type = union_type

    def execute(self, **kwargs):
        return f"{execute(self.q1, **kwargs)} {self.union_type} {execute(self.q2, **kwargs)}"
    

# %% ../nbs/04_queries.ipynb 9
class Exists:
    """Exists statement"""
    def __init__(self, query) -> None:
        super().__init__()
        self.query = query
        self.get_sql = self.execute

    def execute(self, **kwargs):
        return f"EXISTS ({self.query.get_sql(**kwargs)})"


